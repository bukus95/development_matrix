# Asynchronous execution
1. Как отменить запущенные таймеры? *
2. Обратные вызовы против Promise? *
3. Цепочка обещаний. Что такое `then`, `catch`, `finally`?** 
4. Promise.all vs Promise.allSettled?**
5. Можем ли мы использовать await в коде верхнего уровня? (https://github.com/tc39/proposal-top-level-await)**
6. Какие подходы к обработке ошибок вы знаете?**
7. Tasks vs microtasks?***
8. Что такое цикл событий в JavaScript?***

## 1. Как отменить запущенные таймеры
Для отмены таймера, запущенного с помощью `setTimeout()`, есть специальная функция `clearTimeout()`. 
Она принимает на вход идентификатор таймаута, который возвращает `setTimeout()` и останавливает таймер (переданный колбэк не выполнится).

```javascript
// запускаем таймер
const timerId = setTimeout(() => console.log('hello!'), 1000);
// останавливаем таймер
clearTimeout(timerId);
```

Для отмены интервала, запущенного с помощью `setInterval()`, есть схожая функция `clearInterval()`

```javascript
// запускаем интервал
const timerId = setInterval(() => console.log('hello!'), 1000);
// останавливаем
clearInterval(timerId);
```
Несмотря на то, что функции `clearTimeout()` и `clearInterval()`, работают схожим образом и взаимозаменяемы, 
всё же лучше использовать каждую функцию по своему назначению, то есть с помощью `clearTimeout()` останавливать таймаут, а `clearInterval()` останавливать интервал.

## 2. Обратные вызовы против Promise
### Сallback function
Сallback function — это функция, которая передается в другую функцию в качестве аргумента. 
В дальнейшем она может быть вызвана в любое время той функцией, в которую мы ее передали. 
Функция, принимающая другую функцию в качестве аргумента, называется функцией высшего порядка.

```javascript
function someFunctionAcceptingCallback(number, callback){
return callback(number + 10)
}
function divide(answer) {
return answer / 2
}
someFunctionAcceptingCallback(5, divide) // 7.5 при условии console.log
```
Ад обратных вызовов
Если же нам потребуются сетевые запросы по порядку, сначала первый, потом второй и т.д., то это обернется усложнением кода. Рассмотрим пример:

```javascript
const user = new XMLHttpRequest();
     user.open("GET", "/user");
     user.send();
     user.onload = () => {

         const getPosts = new XMLHttpRequest();
         getPosts.open("GET", `/posts${user.response.id}`);
         getPosts.send();
         getPosts.onload = () => {

             const getMessages = new XMLHttpRequest();
             getMessages.open("GET", `/messages${user.response.id}`);
             getMessages.send();
             getMessages.onload = () => {
                 // Останавливаем загрузку и выводим данные пользователя на экран
             }
         }
     }
```
Довольно сложно прочитать данный код из-за привычки последовательно мыслить. 
Он чреват ошибками и может стать еще более запутанным. 
Мы должны проверять каждый запрос на наличие ошибок. В результате окончательный код будет намного длиннее, 
менее читаемым, а следовательно, более сложным в обслуживании и подверженным ошибкам.

### Promises

#### Что такое промис?

До появления промисов в нативном JavaScript для асинхронного программирования применялись другие методы и библиотеки, поскольку не было никакой возможности использовать для этой цели нативный JavaScript.

Промисы стали большим событием для разработчиков JavaScript, поскольку они облегчали написание асинхронных сетевых запросов и позволяли избежать ада обратных вызовов.

Ранее упоминалось, что XMLHttpRequest является WEB API. Учитывая однопоточный характер JavaScript, во избежание блокировки кода мы должны передать асинхронные функции во что-то иное, чем стек вызовов.

Однако промисы не используют очередь обратных вызовов. Тогда что же они задействуют для асинхронного кода?

#### Очередь микрозадач
Данная функциональность была представлена в ES6. Она аналогична очереди обратных вызовов, но применительно к промисам и с некоторыми отличиями. Очередь микрозадач micro queue имеет приоритет перед callback queue. Приведем пример кода:

```javascript
setTimeout(() => {
console.log("Using callback queue")

}, 0)

new Promise(resolve => resolve(console.log("Using micro queue")))
```
Как видно, `setTimeout` запускает обратный вызов сразу через 0 секунд, и промис также настроен сделать это немедленно. 
Но несмотря на это, промис сначала запустит свой обратный вызов. Дело в том, что он задействует очередь микрозадач, имеющую приоритет над очередью обратных вызовов, которую использует метод WEB API setTimout.

Углубляясь в тему промисов, отметим, что они имеют 3 состояния: pending (ожидает выполнения), fulfilled (выполнено), rejected (отклонено).

`pending` указывает на то, что выполнение или отклонение промиса еще не произошло. В контексте запроса API это означает следующее: мы делаем запрос, сервер не присылает никакого ответа, вследствие чего промис пребывает в состоянии ожидания.

`fulfilled` — показатель того, что получен успешный ответ на запрос и промис выполнен.

`rejected` означает, что промис отклонен. Это происходит, когда мы получаем ответ 404 и перехватываем ошибку.

Например, мы можем создать промис с 3-х секундным ожиданием и по истечении этого времени успешно его выполнить. Это означает возможность осуществления одних задач после завершения других в нативном JavaScript без библиотек для целей асинхронного кода. Это касается всех случаев, в которых нам неизвестно время получения ответа.

После промиса мы можем задействовать `.then()`. Отметим, что все действия, прописанные в данном методе, осуществляются только после результативного завершения промиса. Для примера создадим промис, который выполняется через 3 секунды и передает строку в `resolve`:
```javascript
const myPromise = new Promise((resolve, reject) => {
setTimeout(() => {
resolve("I'm resolved")
}, 3000)
})
myPromise.then(res => console.log(res)) // I'm resolved 
// Мы также можем обернуть fetch в промис:

const myPromise = new Promise((resolve, reject) => {
fetch('url').then(res => res.json().then((json) => resolve(json)))
})
myPromise.then(res => console.log(res)) // данные json
```
`Fetch` тоже основан на промисах. При вызове `.then()` для fetch мы просто ждем, пока сервер не выполнит промис/вернет ответ.

#### Цепочки промисов
Вместо ада обратных вызовов можно разными способами связать промисы в цепочки. Если необходимо после первого успешного запроса сделать еще один, предпринимаем следующее:
```javascript
const myPromise = new Promise((resolve, reject) => {
fetch('https://jsonplaceholder.typicode.com/todos/1')
.then(res => res.json().then((json) => resolve(json)))
})
myPromise.then((res) => doSomething(res)).then(() => console.log("Okey now i'm done!"))
```
В этом примере мы получаем `todo`, преобразуем ответ в `JSON` и приводим в исполнение. Затем применяем `.then()` для `myPromise`, который становится итоговым значением промиса. После этого вызываем функцию `doSomething()` с данными `JSON` и выводим сообщение о завершении работы.


## 3.Что такое then, catch, finally

Объект `Promise` служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), 
которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов `.then` и `.catch`.

```javascript
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```

Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

Второй аргумент `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

Например, вот реакция на успешно выполненный промис:

```javascript
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
  result => alert(result), // выведет "done!" через одну секунду
  error => alert(error) // не будет запущена
);
```

### catch
Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает то же самое:

```javascript
let promise = new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это то же самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```
>Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f).

### Очистка: finally
По аналогии с блоком `finally` из обычного `try {...}` `catch {...}`, у промисов также есть метод `finally`.

Вызов `.finally(f)` похож на `.then(f, f)`, в том смысле, что `f` выполнится в любом случае, когда промис завершится: успешно или с ошибкой.

Идея `finally` состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.

Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и т.д.

Думайте об этом как о завершении вечеринки. Независимо от того, была ли вечеринка хорошей или плохой, сколько на ней было друзей, нам все равно нужно (или, по крайней мере, мы должны) сделать уборку после нее.

Код может выглядеть следующим образом:

```javascript
new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve или может reject */
})
  // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => 'остановить индикатор загрузки')
  // таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
  .then(result => 'показать результат, err => показать ошибку')
```
Обратите внимание, что `finally(f)` – это не совсем псевдоним `then(f,f)`, как можно было подумать.

Есть важные различия:

1. Обработчик, вызываемый из `finally`, не имеет аргументов. В `finally` мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.
Пожалуйста, взгляните на приведенный выше пример: как вы можете видеть, обработчик `finally` не имеет аргументов, а результат promise обрабатывается в следующем обработчике.

2. Обработчик `finally` «пропускает» результат или ошибку дальше, к последующим обработчикам.

Например, здесь результат проходит через `finally` к `then`:

```javascript
new Promise((resolve, reject) => {
  setTimeout(() => resolve("value"), 2000);
})
  .finally(() => alert("Промис завершён")) // срабатывает первым
  .then(result => alert(result)); // <-- .then показывает "value"
```
Как вы можете видеть, значение возвращаемое первым промисом, передается через `finally` к следующему `then`.

Это очень удобно, потому что finally не предназначен для обработки результата промиса. Как уже было сказано, это место для проведения общей очистки, независимо от того, каков был результат.

А здесь ошибка из промиса проходит через `finally` к `catch`:

```javascript
new Promise((resolve, reject) => {
  throw new Error("error");
})
  .finally(() => alert("Промис завершён")) // срабатывает первым
  .catch(err => alert(err));  // <-- .catch показывает ошибку
```
3. Обработчик `finally` также не должен ничего возвращать. Если это так, то возвращаемое значение молча игнорируется.

Единственным исключением из этого правила является случай, когда обработчик `finally` выдает ошибку. Затем эта ошибка передается следующему обработчику вместо любого предыдущего результата.

## 4. Promise.all vs Promise.allSettled
Оба метода `Promise.all()` и `Promise.allSettled()` являются методами объекта `Promise` (который также является объектом `JavaScript`, используемым для обработки всех асинхронных операций), которые используются для одновременной обработки нескольких результатов обещаний. Ввод обоих методов представляет собой массив, содержащий промисы, которые также содержат некоторые данные внутри них.

```javascript
Promise.all([promise_1 , promise_2,  ...other]).then(
    // do something...
)
Promise.allSettled([promise_1 , promise_2,  ...other]).then(
    // do something...
)
```

### Чем они отличаются друг от друга?

Ниже приведены некоторые из наиболее важных моментов, которые помогут нам понять их разницу (и это тоже с помощью некоторых примеров кодирования):

1. В плане отказа от обещаний:

* Метод `Promise.all()` отклоняет себя, если какой-либо из переданных в обещании входных данных внутри массива отклонен. То есть этот метод будет работать только тогда и только тогда, когда все промисы выполнены или успешно разрешены, иначе на выходе он выдаст сообщение об ошибке.
* Метод `Promise.allSettled()` не отклонит себя, если какой-либо из переданных в обещании входных данных внутри массива будет отклонен. То есть этот метод, вне зависимости от любого промиса, тоже будет в отклоненном состоянии.
2. С точки зрения их результатов:

* Метод `Promise.all()` возвращает в качестве вывода массив, содержащий данные промисов внутри нескольких индексов.
* Метод `Promise.allSettled()` возвращает массив объектов, и каждый из этих объектов дополнительно содержит два свойства: статус и значение.

```javascript
 let first_promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("Resolved First after 1 second");
        }, 1000);
    });
  
    let second_promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("Resolved First after 2 seconds");
        }, 2000);
    });
  
    try {
        let result_1 = Promise.all(
            [first_promise, second_promise]);
  
        result_1.then((data) => console.log(data));
  
        let result_2 = Promise.allSettled(
            [first_promise, second_promise]);
          
        result_2.then((data) => console.log(data));
    } catch (error) {
        console.log(error);
    }
    //[ 'Решено первым через 1 секунду', 'Решено первым через 2 секунды' ]
    //[
    //  { статус: 'выполнено', значение: 'Решено первым через 1 секунду' },
    //  { статус: 'выполнено', значение: 'Решено первым через 2 секунды' }
    //]
```

## 5. Await
Оператор `await` используется для ожидания `Promise` и получения значения выполнения.
Его можно использовать только внутри асинхронной функции или на верхнем уровне модуля.

`await` обычно используется для развертывания промисов путем передачи a `Promiseв` качестве `expression`. 
Использование `await` приостанавливает выполнение окружающей его `async` функции до тех пор, пока обещание не будет выполнено (то есть выполнено или отклонено). Когда выполнение возобновляется, значение выражения `await` становится значением выполненного обещания.

Если обещание отклонено, `await` выражение выдает отклоненное значение. Функция, содержащая `await` выражение, появится в трассировке стека ошибки. В противном случае, если отклоненное обещание не ожидается или возвращается немедленно, вызывающая функция не появится в трассировке стека.
```javascript
function resolveAfter2Seconds(x) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(x);
    }, 2000);
  });
}

async function f1() {
  const x = await resolveAfter2Seconds(10);
  console.log(x); // 10
}

f1();
```
### Top level await
Вы можете использовать `await` ключевое слово отдельно (вне асинхронной функции) на верхнем уровне модуля. Это означает, что модули с дочерними модулями, которые используют, `await` будут ждать выполнения дочерних модулей, прежде чем они сами запустятся, при этом не блокируя загрузку других дочерних модулей.

Вот пример простого модуля, использующего `Fetch API` и указывающего ожидание в `export` операторе. Любые модули, которые включают это, будут ждать разрешения выборки, прежде чем запускать какой-либо код.

```javascript
// awaiting.mjs
import { process } from "./some-module.mjs";
const dynamic = import(computedModuleSpecifier);
const data = fetch(url);
export const output = process((await dynamic).default, await data);
```
```javascript
// usage.mjs
import { output } from "./awaiting.mjs";
export function outputPlusValue(value) { return output + value }

console.log(outputPlusValue(100));
setTimeout(() => console.log(outputPlusValue(100), 1000));
```
## 6. Какие подходы к обработке ошибок вы знаете

Ошибка в JS - это «выбрасывание» исключения (throw of an exception). Исключение должно быть обработано программой, в противном случае интерпретатор вернет нас на то место, где это исключение было выброшено. По умолчанию исключение выбрасывает объект Error.

Неважно, пишете ли вы Frontend или Backend, подход к обработке один – поймать злосчастное исключение и обработать. Обрабатывать нужно все, особенно в проде.

Сразу просветим пару нестандартных ситуаций (кому как):

* ошибка извне программы,
* терминальная ошибка.

Терминальная ошибка – это код ошибки, который возвращает ОС или демон.

Ошибка извне программы может быть частным случаем терминальной, но тем не менее она должна быть обработана.

Любая из этих нестандартных ситуаций может попасть в общий стек ошибок и будет обработана, т.к. каждое выброшенное исключение, попавшее в программу, захватывает стек.

### Инструкция throw
Используйте инструкцию throw, чтобы выбросить исключение. При выбросе исключения нужно указать выражение, содержащее значение, которое будет выброшено:

`throw expression;`
Вы можете выбросить любое выражение, а не только выражения определённого типа. В следующем примере выбрасываются исключения различных типов:
```javascript
throw "Error2";                                              // string
throw 42;                                                    // number
throw true;                                                  // boolean
throw { toString: function() { return "I'm an object!"; } }; // object
```
Инструкция `try...catch`
Инструкция `try...catch` состоит из блока `try`, который содержит одну или несколько инструкций, и блок `catch`, которые содержит инструкции, определяющие порядок действий при выбросе исключения в блоке `try`. Иными словами, если в блоке `try` будет выброшено исключение, то управление будет передано в блок `catch`. Если в блоке `try` не возникнет исключений, то блок `catch` будет пропущен. Блок `finally` будет выполнен после окончания работы блоков `try` и `catch`, вне зависимости от того, было ли выброшено исключение.

В следующем примере вызывается функция `getMonthName`, которая возвращает название месяца по его номеру. Если месяца с указанным номером не существует, то функция выбросит исключение "`InvalidMonthNo`", которое будет перехвачено в блоке `catch`:
```javascript
function getMonthName(mo) {
  mo = mo - 1; // Adjust month number for array index (1 = Jan, 12 = Dec)
  var months = ["Jan","Feb","Mar","Apr","May","Jun","Jul",
                "Aug","Sep","Oct","Nov","Dec"];
  if (months[mo]) {
    return months[mo];
  } else {
    throw "InvalidMonthNo"; //throw keyword is used here
  }
}

try { // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
}
catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler -> your own
}
```
### Блок finally
Блок `finally` содержит код, который будет выполнен после окончания работы блоков `try` и `catch`, но до того, как будет выполнен код, который следует за инструкцией `try...catch`. Блок `finally` выполняется вне зависимости от того, было ли выброшено исключение. Блок `finally` выполняется даже в том случае, если исключение не перехватывается в блоке `catch`.

В следующем примере открывается файл, затем в блоке `try` происходит вызов функции `writeMyFile`, который может выбросить исключение. Если возникает исключение, то оно обрабатывается в блоке `catch`. В любом случае файл будет закрыт функцией `closeMyFile`, вызов которой находится в блоке `finally`.
```javascript
openMyFile();
try {
  writeMyFile(theData);
} catch(e) {
  handleError(e);
} finally {
  closeMyFile();
}
```
Если блок `finally` возвращает значение, то данное значение становится возвращаемым значением всей связки `try-catch-finally`. Значения, возвращаемые блоками `try` и `catch`, будут проигнорированы.
