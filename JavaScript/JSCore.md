# JS Core
1. [Какие примитивы существуют в JS?](#1.-kakie-primitivy-sushestvuyut-v-js)
2. [Являются ли примитивные значения/объекты изменяемыми или неизменяемыми?](#2.-yavlyayutsya-li-primitivnye-znacheniya-obekty-izmenyaemymi-ili-neizmenyaemymi)
3. [Как работает принуждение? Опишите, как он сравнивает следующее: 3 > 2 > 1.](#3.-kak-rabotaet-prinuzhdenie)
4. [Можем ли мы удалить (используя оператор удаления) любое свойство, объявленное с помощью var/let/const, из глобальной области видимости или из области действия функции?](#4.-mozhem-li-my-udalit-ispolzuya-operator-udaleniya-lyuboe-svoistvo-obyavlennoe-s-pomoshyu-var-let-c)
5. [Какие типы областей существуют?](#5.-kakie-tipy-oblastei-sushestvuyut)
6. [Что определяет значение this?](#6.-chto-opredelyaet-znachenie-this)
7. [Есть ли у нас «аргументы» в стрелочных функциях? Может ли стрелочная функция быть конструктором?](#7.-est-li-u-nas-argumenty-v-strelochnykh-funkciyakh-mozhet-li-strelochnaya-funkciya-byt-konstruktoro)
8. [Спред против остальных операторов?](#8.-spread-protiv-rest-operatorov)
9. [Эмулировать закрытые методы в JavaScript с замыканиями (перенесено из раздела Scope).](#9.-emulirovat-zakrytye-metody-v-javascript-s-zamykaniyami.)
10. Известные символы? Как создать общие символы в глобальном реестре символов?
11. Какие типы могут быть ключами свойств объекта?
12. Нулевое объединение или логический оператор ИЛИ?
13. Как преобразовать объект в примитивное значение? (значение/символ.ToPrimitive)

## 1. Какие примитивы существуют в JS?
#### JavaScript имеет примитивные типы данных(все они имутабельные):
1. `null` - является вторым примитивным типом данных, который также имеет только одно значение null
2. `undefined` - автоматически присваиваемое только что объявленным переменным или формальным аргументам, для которых нет фактических аргументов.
3. `boolean` - это логический тип данных, который может принимать только значения true или false
4. `number` - тип для представления как целых чисел, так и чисел с плавающей запятой
5. `string` - это последовательность из нуля или более символов. Строковый литерал начинается и заканчивается либо одинарной кавычкой ( '), либо двойной кавычкой ( ")
6. `symbol` – available from ES2015  в отличие от других примитивных типов, этот `symbol` тип не имеет буквальной формы `let s1 = Symbol()`
7. `bigint` – available from ES2020 представляет целые числа, которые больше 2 53  – 1. Чтобы сформировать `bigint` буквальное число, вы добавляете букву `n` в конце числа

## 2. Являются ли примитивные значения/объекты изменяемыми или неизменяемыми?
Все примитивы неизменяемы, то есть они не могут быть изменены. 
Важно не путать сам примитив с переменной, которой присвоено значение примитива. 
Переменная может быть переназначена новому значению, но существующее значение не может быть изменено способами, 
которыми могут быть изменены объекты, массивы и функции.

## 3. Как работает принуждение?
`Приведение типов` — это автоматическое или неявное преобразование значений из одного типа данных 
в другой (например, строк в числа). `Преобразование типов` похоже на приведение типов, потому что они оба преобразуют
значения из одного типа данных в другой с одним ключевым отличием — приведение типов является неявным, 
тогда как преобразование типов может быть как неявным, так и явным.

**Явное**: String(), Number(), Boolean()

**Неявное**:
3 типа преобразования: строковое, числовое, булевое

- СТРОКОВОЕ:
  происходит при использовании бинарного оператора “+”, если  один из операндов - строка
- БУЛЕВОЕ:
  происходит в логическом контексте: if (val) {}, ||, &&, !
- ЧИСЛЕННОЕ:
  при использовании >, <, <=,>=, | & ^ ~, - + * / %, == (включая !=).
> Обратите внимание, что данный оператор не вызывает численное преобразование, если оба операнда являются строками
При преобразовании строки в число, движок сначала отсекает все пробельные символы, символы `\n`, и `\t` в начале и в конце строки, и возвращает NaN если обрезанная строка не представляет из себя корректное число. Если строка окажется пустой, то результатом будет 0.
`null` и `undefined` обрабатываются по-разному: `null` станет `0`, в то время как `undefined` станет `NaN`

При применении `==` к `null` или `undefined`, численное преобразование не происходит, так как `null` может равняться только `null` или `undefined`, и ничему другому:
`null == 0` // false, null is not converted to 0

> `NaN` не равен ничему, даже самому себе
```javascript
const value1 = "5";
const value2 = 9;
let sum = value1 + value2;

console.log(sum);
```
В приведенном выше примере JavaScript преобразовал from число 9 в строку, а затем объединил два значения вместе, 
в результате чего появилась строка 59. У JavaScript был выбор между строкой и числом, и он решил использовать строку.

Компилятор мог бы 5 преобразовать в число и вернуть сумму 14, но этого не произошло. 
Чтобы вернуть этот результат, вам нужно будет явно преобразовать 5 в число, используя `Number()`

## 4. Можем ли мы удалить (используя оператор удаления) любое свойство, объявленное с помощью var/let/const, из глобальной области видимости или из области действия функции?
Оператор `delete` удаляет свойство из объекта. Он не может удалить переменную. 
Любое свойство, объявленное с `var/let/const` помощью, нельзя удалить из глобальной области или из области действия функции.
```javascript
var x = 1
console.log(delete x) // return false
console.log(x) // x is still 1
```
Если объявить переменную без `var/let/const` то ее можно удалить, так как она сохраняется в свойство объекта `window`. 
Таким образом мы можем удалить ее. 

## 5. Какие типы областей существуют?
`Область видимости` — это область где можно получить доступ к значениям и функциям.
Есть 3 типа:
1. Глобальная область видимости
2. Область видимости функции
3. Область видимости блока(ES6)

`Глобальные переменные` JavaScript, объявленные вне блоков или функций, могут существовать в `глобальной области видимости`,
что означает, что они доступны во всей программе. 
Переменные, объявленные за пределами меньших областей блоков или функций, доступны внутри этих меньших областей.
```javascript
// Variable declared globally
const color = 'blue';

function printColor() {
  console.log(color);
}

printColor(); // Prints: blue
```
`Область видимости функции`:
В JavaScript есть область видимости функции: каждая функция создает новую область видимости.
Переменные, определенные внутри функции, недоступны (видимы) снаружи функции.
Переменные, объявленные с помощью `var`, `let` и `const` очень похожи при объявлении внутри функции.
Все они имеют область действия:
```javascript
function myFunction() {
  var carName = "Volvo";   // Function Scope
}
```
`Область видимости блока` - переменные (`let`, `const`) объявлены внутри блока `{}` могут быть доступны только внутри него.

## 6. Что определяет значение this?
В большинстве случаев значение `this` определяется тем, каким образом вызвана функция. 
Значение `this` не может быть установлено путём присваивания во время исполнения кода и может иметь разное значение 
при каждом вызове функции. В ES5 представлен метод `bind()`, который используется для привязки значения ключевого
слова `this` независимо от того, как вызвана функция. 
```javascript
const test = {
  prop: 42,
  func: function() {
    return this.prop;
  },
};

console.log(test.func());
// Expected output: 42

```
Также в ES2015 представлены стрелочные функции,
которые не создают собственные привязки к `this` (они сохраняют значение `this` лексического окружения, в котором были созданы).
```javascript
var globalObject = this;
var foo = (() => this);
console.log(foo() === globalObject); // true
```

## 7. Есть ли у нас «аргументы» в стрелочных функциях? Может ли стрелочная функция быть конструктором?

Выражения стрелочных функций имеют более короткий синтаксис по сравнению с функциональными выражениями и лексически 
привязаны к значению this (но не привязаны к собственному this, arguments, super, или new.target). 
Выражение стрелочных функций не позволяют задавать имя, поэтому стрелочные функции анонимны, если их ни к чему не присвоить.
Объект `arguments` - это локальная переменная, доступная внутри любой (нестрелочной) функции. Объект `arguments` 
позволяет ссылаться на аргументы функции внутри неё. Он состоит из переданных в функцию аргументов, индексация начинается с 0.
> Не имеет собственного объекта arguments

Стрелочные функции не имеют собственного объекта arguments, 
поэтому в теле стрелочных функций arguments будет ссылаться на переменную в окружающей области.
```javascript
var arguments = 42;
var arr = () => arguments;
arr(); // 42

function foo() {
  var f = (i) => arguments[0] + i; // Неявное связывание ссылки arguments
                                   // стрелочной функции f
                                   // c объектом arguments функции foo
  return f(2);
}

foo(1); // 3
```
В большинстве случаев лучшей заменой объекта arguments в стрелочных функциях являются остаточные параметры:
```javascript
function foo() {
  var f = (...args) => args[0];
  return f(2);
}

foo(1); // 2
```
### Использование оператора `new`
Стрелочные функции не могут быть использованы как конструктор и вызовут ошибку при использовании с new:
```javascript
var a = new (function() {})
// переменной "a" будет присвоено значение экземпляра анонимной функции

var b = new (() => {})
// будет выброшено исключение
// Uncaught TypeError: (intermediate value) is not a constructor
```

## 8. Spread против Rest операторов?
Оператор `Spread` и параметры `Rest` имеют один и тот же оператор `...` разница в том, что оператор `Spread` мы передаем 
или распространяем отдельные данные массива на другие данные, в то время как параметры `Rest` используют в функции или 
массиве для деструктуризации всех аргументов или значений.
Spread syntax
```javascript
function sum(x, y, z) {
  return x + y + z;
}

const numbers = [1, 2, 3];

console.log(sum(...numbers));
// Expected output: 6

console.log(sum.apply(null, numbers));
// Expected output: 6
```
Rest syntax
```javascript
function sum(...theArgs) {
  let total = 0;
  for (const arg of theArgs) {
    total += arg;
  }
  return total;
}

console.log(sum(1, 2, 3));
// Expected output: 6

console.log(sum(1, 2, 3, 4));
// Expected output: 10
```
## 9. Эмулировать закрытые методы в JavaScript с замыканиями.

### Что такое Замыкания?
Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. 
Другими словами, замыкание даёт вам доступ к Scope внешней функции из внутренней функции. 
В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
Рассмотрим следующий пример:

```javascript
function makeFunc() {
var name = "Mozilla";

function displayName() {
alert(name);
}

return displayName;
};

var myFunc = makeFunc();
myFunc();
```
Если выполнить этот код, то результат будет такой же, как и выполнение `init()` из предыдущего примера: строка "Mozilla" будет показана в JavaScript alert диалоге. Что отличает этот код и представляет для нас интерес, так это то, что внутренняя функция displayName() была возвращена из внешней до того, как была выполнена.

На первый взгляд, кажется неочевидным, что этот код правильный, но он работает. В некоторых языках программирования локальные переменные-функции существуют только во время выполнения этой функции. После завершения выполнения makeFunc() можно ожидать, что переменная name больше не будет доступна. Однако, поскольку код продолжает нормально работать, очевидно, что это не так в случае JavaScript.

Причина в том, что функции в JavaScript формируют так называемые замыкания. Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. В рассмотренном примере myFunc — это ссылка на экземпляр функции displayName, созданной в результате выполнения makeFunc. Экземпляр функции displayName в свою очередь сохраняет ссылку на своё лексическое окружение, в котором есть переменная name. По этой причине, когда происходит вызов функции myFunc, переменная name остаётся доступной для использования и сохранённый в ней текст "Mozilla" передаётся в alert.

### Эмуляция частных (private) методов с помощью замыканий

Языки вроде Java позволяют нам объявлять частные (private) методы . Это значит, что они могут быть вызваны только методами того же класса, в котором объявлены.

JavaScript не имеет встроенной возможности сделать такое, но это можно эмулировать с помощью замыкания. Частные методы полезны не только тем, что ограничивают доступ к коду, это также мощное средство глобальной организации пространства имён, позволяющее не засорять публичный интерфейс вашего кода внутренними методами классов.

Код ниже иллюстрирует, как можно использовать замыкания для определения публичных функций, которые имеют доступ к закрытым от пользователя (private) функциям и переменным. Такая манера программирования называется модульное программирование

```javascript
var Counter = (function() {
  var privateCounter = 0;

  function changeBy(val) {
    privateCounter += val;
  }

  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  };
})();

alert(Counter.value()); /* Alerts 0 */

Counter.increment();
Counter.increment();

alert(Counter.value()); /* Alerts 2 */

Counter.decrement();

alert(Counter.value()); /* Alerts 1 */

```
Здесь мы создаём единое окружение для трёх функций: Counter.increment, Counter.decrement, и Counter.value.

Единое окружение создаётся в теле анонимной функции, которая исполняется в момент описания. Это окружение содержит два приватных элемента: переменную privateCounter и функцию changeBy(val). Ни один из этих элементов не доступен напрямую, за пределами этой самой анонимной функции. Вместо этого они могут и должны использоваться тремя публичными функциями, которые возвращаются анонимным блоком кода (anonymous wrapper), выполняемым в той же анонимной функции.

Эти три публичные функции являются замыканиями, использующими общий контекст исполнения (окружение). Благодаря механизму lexical scoping в Javascript, все они имеют доступ к переменной privateCounter и функции changeBy.

Заметьте, мы описываем анонимную функцию, создающую счётчик, и тут же запускаем её, присваивая результат исполнения переменной Counter. Но мы также можем не запускать эту функцию сразу, а сохранить её в отдельной переменной, чтобы использовать для дальнейшего создания нескольких счётчиков
